
---
cover: https://cdn-images-1.readmedium.com/v2/resize:fit:800/0*uhuIBeogWZWFx-Bj
date: '2024-08-09 07:04:51'
tags:
  - 内存管理
  - LangGraph
  - 人机交互
title: LangGraph 初学者指南内存第 3 部分

---


LangGraph 内存解析



在 LangGraph 中，内存在维护上下文和增强智能系统功能方面发挥着至关重要的作用。**持久内存**是指在多次交互中保留信息的能力，使系统能够回忆过去的状态和决策，这对于创建连贯且具有上下文意识的对话至关重要。**检查点**是内存的一个特定实现，它在执行过程中在不同点保存图的状态，使系统能够在中断时从该点恢复。这与 LangGraph 中的**状态**的普遍概念不同，状态表示应用程序在任何给定时刻的*当前快照*。虽然状态是动态的，并随着图的执行而变化，但持久内存和检查点提供了一种存储和检索历史状态的方法，从而促进更复杂的工作流程和人机交互。

包含代码的笔记本**可在 [这里](https://github.com/DhunganaKB/OpenAI-Chat/blob/main/LangGraph/langGraph_memory_turorial_03.ipynb) 获取。**

要运行此笔记本，您必须拥有 OpenAI 和 Tavily 的有效 API 密钥。

参考 LangChain 的内容**可在 [这里](https://langchain-ai.github.io/langgraph/how-tos/persistence/?h=memo) 获取。**

**状态与检查点的区别**

**状态**：它表示应用程序在任何给定时刻的当前快照。它是动态的，并随着图中节点的执行而演变，反映实时变化和更新。节点使用状态来执行计算并确定工作流程中的下一步。

**检查点**：检查点是在图执行过程中某一特定时间点保存的状态版本。*它允许系统暂停并恢复执行，为未来的交互保留上下文。* 检查点通过使用户能够在继续执行之前检查和修改状态，从而促进人机交互工作流程。

**线程 ID**

在 LangGraph 中，**thread\_id**是与系统内特定执行线程相关的唯一标识符。每个线程代表一个独特的交互或对话流，使系统能够同时管理多个对话或过程。*LangGraph 中的内存与 thread\_id 关联的方式如下*：

**状态管理**：每个线程维护自己的状态，随着线程的进展而更新。这确保了该特定线程的交互上下文得以保留。

**检查点**：检查点在线程的上下文中保存，使系统能够从该线程执行的特定点恢复。这对于需要用户输入或在各个阶段获得批准的工作流程至关重要。

**内存隔离**：通过将内存与 thread\_id 关联，LangGraph 可以隔离不同线程的内存和状态，防止并发交互之间的干扰，确保每个线程独立运行。总体而言，thread\_id 是组织和管理 LangGraph 中内存的关键机制，能够有效跟踪状态和保持交互连续性。

**检查点如何保存？**

在 LangGraph 中，检查点使用内置的持久性层进行保存，允许在执行过程中在不同点存储图的状态。以下是检查点的管理方式和位置：

**检查点管理器**：LangGraph 利用检查点管理器，这些组件负责保存图的状态。这些可以使用不同的存储后端实现，***例如内存存储或 SQLite 等数据库。***

**保存机制**：在图执行的每个超级步骤中都会创建检查点。这意味着在每个节点处理其输入并更新状态后，当前状态将作为检查点保存。

**内存存储：**

内存存储是指存储在计算机主内存（RAM）中的数据。这种类型的存储允许非常快速地访问和检索数据，因为它不涉及磁盘 I/O 操作。

以下示例说明了如何在内存中存储检查点，并在需要时检索：它最初保存到内存中，然后从内存中访问。

![](https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*pTCqvi2QrCRFLMhICxiiyQ.png)

**持久存储 — SQLite：**

持久存储是指存储在非易失性介质上的数据，例如硬盘、SSD 或云存储。这种类型的存储即使在应用程序停止或系统断电时也能保留数据。

![](https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*Ua8kPzNit3Rjz10Ug94AxQ.png)

**将内存添加到图中**

到目前为止，我们已经探讨了内存、检查点、状态和线程的概念，以及如何将状态对象存储在内存中。现在，让我们将这些内存集成到图中，并观察它如何增强图的能力。

第一步是构建一个图，并分别编译带有和不带有内存的图。然后，我们将评估将内存集成到图中与不带有内存的图相比的好处。实际上，内存的存在使图能够在后续运行中保留先前执行的历史数据。

这是一个基本图，包含一个搜索工具节点和一个代理节点。我们在早期文章中详细介绍了该图中使用的各种组件。我强烈建议您查看我们之前的入门文章，以深入讨论每个组件。

![](https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*Rp9Xhdcryy486PQzUgGupQ.png)

现在图中包含内存，让我们比较带有和不带有内存的图的多次执行输出。这种比较将帮助我们理解集成内存的重要性。

**带有内存的图**

正如我们之前提到的，在 LangGraph 中，检查点与 thread\_id 关联，以有效管理不同执行线程的状态和内存。当图执行时，在执行的各个点（超级步骤）创建检查点。每个检查点捕获图的当前状态，包括变量的值和执行上下文。检查点存储在持久或内存存储系统中，每个检查点都标记有相应的 thread\_id。此标记允许系统按其关联的线程对检查点进行分组，确保可以准确检索每个线程的状态。

下面，我们可以观察到当使用内存时，新运行保留了先前运行的信息。例如，在第一次运行中，我们查询图关于圣路易斯的信息。在随后的运行中，我们提到了之前的位置。第二次运行识别了第一次运行中的位置名称。

![](https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*Y7aszSGWRMK2mPFA0WndVA.png)

我们可以轻松访问指定线程的历史记录。

![](https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*8d8BL2u6d1yb-FNj29pHYA.png)

**不带内存的图**

让我们执行不带内存的图。我们将提出与之前相同的问题，并观察响应如何不同。

不带内存的图描述如下：

```python
graph = workflow.compile()
```
如下所示，当前运行不保留先前运行的信息。在第三次运行中，当我们询问之前的位置时，它能够识别地点的名称，但未能回应用户的查询。

![](https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*gloCuQHotul9fLazqM1xyA.png)

不带内存的图在多轮对话中难以保持连贯性，因为它无法回忆过去的交互。相比之下，带有内存的图能够保留先前交流的上下文，从而促进更自然和引人入胜的对话。将内存集成到图中的主要优势在于其能够从过去的经验中学习，从而提高其性能和适应性，最终导致更丰富的用户交互。
